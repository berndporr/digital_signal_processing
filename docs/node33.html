<!DOCTYPE HTML>

<!--Converted with LaTeX2HTML 2019.2 (Released June 5, 2019) -->
<HTML lang="EN">
<HEAD>
<TITLE>IIR Filter</TITLE>
<META NAME="description" CONTENT="Digital Signal Processing">
<META NAME="keywords" CONTENT="DSP, Python, Digital, Signals, Engineering, Computer science">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META CHARSET="UTF-8">

<META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=utf-8">
<META NAME="viewport" CONTENT="width=device-width, initial-scale=1.0">
<META NAME="Generator" CONTENT="LaTeX2HTML v2019.2">

<LINK REL="STYLESHEET" HREF="digital_signal_processing.css">

<LINK REL="next" HREF="node34.html">
<LINK REL="previous" HREF="node32.html">
<LINK REL="next" HREF="node34.html">
</HEAD>

<BODY >

<DIV CLASS="navigation"><!--Navigation Panel-->
<A
 HREF="node34.html">
<IMG WIDTH="37" HEIGHT="24" ALT="next" SRC="next.png"></A> 
<A
 HREF="node25.html">
<IMG WIDTH="26" HEIGHT="24" ALT="up" SRC="up.png"></A> 
<A
 HREF="node32.html">
<IMG WIDTH="63" HEIGHT="24" ALT="previous" SRC="prev.png"></A> 
<A ID="tex2html328"
  HREF="node1.html">
<IMG WIDTH="65" HEIGHT="24" ALT="contents" SRC="contents.png"></A>  
<BR>
<B> Next:</B> <A
 HREF="node34.html">The role of poles</A>
<B> Up:</B> <A
 HREF="node25.html">Causal Signal Processing</A>
<B> Previous:</B> <A
 HREF="node32.html">FIR Filter</A>
 &nbsp; <B>  <A ID="tex2html329"
  HREF="node1.html">Contents</A></B> 
<BR>
<BR></DIV>
<!--End of Navigation Panel-->
<!--Table of Child-Links-->
<A ID="CHILD_LINKS"><STRONG>Subsections</STRONG></A>

<UL CLASS="ChildLinks">
<LI><A ID="tex2html330"
  HREF="node33.html#SECTION00078100000000000000">Introduction</A>
<LI><A ID="tex2html331"
  HREF="node33.html#SECTION00078200000000000000">Determining the data-flow diagram of an IIR filter</A>
<LI><A ID="tex2html332"
  HREF="node33.html#SECTION00078300000000000000">General form of IIR filters</A>
<LI><A ID="tex2html333"
  HREF="node33.html#SECTION00078400000000000000">IIR filter topologies</A>
<LI><A ID="tex2html334"
  HREF="node33.html#SECTION00078500000000000000">Fixed point IIR filters</A>
<LI><A ID="tex2html335"
  HREF="node33.html#SECTION00078600000000000000">Filter design based on analogue filters</A>
<UL>
<LI><A ID="tex2html336"
  HREF="node33.html#SECTION00078610000000000000">A list of popular analogue transfer functions being
used for IIR filter design:</A>
<LI><A ID="tex2html337"
  HREF="node33.html#SECTION00078620000000000000">How to transform the analogue lowpass filters into
  highpass, bandstop or bandpass filters?</A>
<LI><A ID="tex2html338"
  HREF="node33.html#SECTION00078630000000000000">Bilinear Transform: transforming the analoge transfer function into a digital one:</A>
<LI><A ID="tex2html339"
  HREF="node33.html#SECTION00078640000000000000">IIR filter design steps:</A>
<LI><A ID="tex2html340"
  HREF="node33.html#SECTION00078650000000000000">Time or frequency domain?</A>
</UL>
<BR>
<LI><A ID="tex2html341"
  HREF="node33.html#SECTION00078700000000000000">Adaptive IIR filter: The Kalman filter</A>
</UL>
<!--End of Table of Child-Links-->
<HR>

<H2><A ID="SECTION00078000000000000000">
IIR Filter</A>
</H2>
IIR filter stands for Infinite Impulse Response. Such filters have
feedback so that signals are processed in a recursive way. We will see
that impulse responses from exponentials can easily be implemented as
a recursive filter.

<P>

<H3><A ID="SECTION00078100000000000000">
Introduction</A>
</H3>
As an instructional example we take a very simple analogue filter and
sample it. This can then be generalised to more complex
situations.

<P>
We define a first order filter which can be implemented, for example, as
a simple RC network:

<DIV class="equation">

<!-- MATH
 \begin{equation}
h(t)=e^{-bt}
\end{equation}
 -->
 &nbsp;  <A ID="ExpoFunktion"></A><IMG STYLE="height: 2.71ex; vertical-align: -0.66ex; " SRC="img376.svg"
 ALT="$\displaystyle h(t)=e^{-bt}
$"> 

(<SPAN CLASS="arabic">151</SPAN>)
</DIV>
where its Laplace transform is a simple fraction:

<DIV class="equation">

<!-- MATH
 \begin{equation}
H(s)=\frac{1}{s+b}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 4.86ex; vertical-align: -1.81ex; " SRC="img377.svg"
 ALT="$\displaystyle H(s)=\frac{1}{s+b}
$"> 

(<SPAN CLASS="arabic">152</SPAN>)
</DIV>
Now we sample Eq.&nbsp;<A HREF="#ExpoFunktion">151</A>:

<DIV class="equation">

<!-- MATH
 \begin{equation}
h(t)=\sum_{n=0}^\infty e^{-bnT} \cdot \delta(t-nT)
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 5.84ex; vertical-align: -2.50ex; " SRC="img378.svg"
 ALT="$\displaystyle h(t)=\sum_{n=0}^\infty e^{-bnT} \cdot \delta(t-nT)
$"> 

(<SPAN CLASS="arabic">153</SPAN>)
</DIV>
and perform a Laplace transform on it:

<DIV class="equation">

<!-- MATH
 \begin{equation}
H(s) = \sum_{n=0}^\infty e^{-bnT} \underbrace{e^{-nsT}}_{{z^{-1}}^n}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 6.46ex; vertical-align: -3.12ex; " SRC="img379.svg"
 ALT="$\displaystyle H(s) = \sum_{n=0}^\infty e^{-bnT} \underbrace{e^{-nsT}}_{{z^{-1}}^n}
$"> 

(<SPAN CLASS="arabic">154</SPAN>)
</DIV>
which turns into a z-transform:
<BR>
<DIV ALIGN="CENTER"><A ID="IIReq"></A>
<!-- MATH
 \begin{eqnarray}
H(z)&=&\sum_{n=0}^\infty e^{-bnT} z^{-n} \\
    &=&\sum_{n=0}^\infty {\left(e^{-bT} z^{-1}\right)}^n \\
    &=&{1\over 1-e^{-bT} z^{-1}}
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img380.svg"
 ALT="$\displaystyle H(z)$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.00ex; vertical-align: -0.09ex; " SRC="img82.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 5.84ex; vertical-align: -2.50ex; " SRC="img381.svg"
 ALT="$\displaystyle \sum_{n=0}^\infty e^{-bnT} z^{-n}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">155</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.00ex; vertical-align: -0.09ex; " SRC="img82.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 5.84ex; vertical-align: -2.50ex; " SRC="img382.svg"
 ALT="$\displaystyle \sum_{n=0}^\infty {\left(e^{-bT} z^{-1}\right)}^n$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">156</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.00ex; vertical-align: -0.09ex; " SRC="img82.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 4.87ex; vertical-align: -1.82ex; " SRC="img383.svg"
 ALT="$\displaystyle {1\over 1-e^{-bT} z^{-1}}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">157</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
Consequently the analogue transfer function <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img251.svg"
 ALT="$H(s)$"></SPAN>
transfers into <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img268.svg"
 ALT="$H(z)$"></SPAN> with the following recipe:

<DIV class="equation">

<!-- MATH
 \begin{equation}
H(s)=\frac{1}{s+b} \qquad\Leftrightarrow\qquad
H(z)=\frac{1}{1-e^{-bT} z^{-1}}
\end{equation}
 -->
 &nbsp;  <A ID="impInv"></A><IMG STYLE="height: 4.87ex; vertical-align: -1.82ex; " SRC="img384.svg"
 ALT="$\displaystyle H(s)=\frac{1}{s+b} \qquad\Leftrightarrow\qquad
H(z)=\frac{1}{1-e^{-bT} z^{-1}}
$"> 

(<SPAN CLASS="arabic">158</SPAN>)
</DIV>
Thus, if you have the poles of an analogue system and you want
to have the poles in the z-plane you can transfer them with:

<DIV class="equation">

<!-- MATH
 \begin{equation}
z_\infty=e^{s_\infty T}
\end{equation}
 -->
 &nbsp;  <A ID="translpoles"></A><IMG STYLE="height: 2.47ex; vertical-align: -0.43ex; " SRC="img385.svg"
 ALT="$\displaystyle z_\infty=e^{s_\infty T}
$"> 

(<SPAN CLASS="arabic">159</SPAN>)
</DIV>
This also gives us a stability criterion. In the Laplace domain
the poles have to be in the left half plane (real value negative).
This means that in the sampled domain the poles have to lie within
the unit circle.

<P>
The same rule can be applied to zeros

<DIV class="equation">

<!-- MATH
 \begin{equation}
z_0=e^{s_0 T}
\end{equation}
 -->
 &nbsp;  <A ID="transzeros"></A><A ID="matchedz"></A><IMG STYLE="height: 0.19ex; vertical-align: -0.09ex; " SRC="img386.svg"
 ALT="$\displaystyle z_0=e^{s_0 T}$"> 

(<SPAN CLASS="arabic">160</SPAN>)
</DIV>
together with Eq.&nbsp;<A HREF="#translpoles">159</A> this is called &ldquo;The matched
z-transform method&rdquo;. For example <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img387.svg"
 ALT="$H(s)=s$"></SPAN> turns into
<!-- MATH
 $H(z)=1-z^{-1}e^{0T}=1-z^{-1}$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.58ex; vertical-align: -0.66ex; " SRC="img388.svg"
 ALT="$H(z)=1-z^{-1}e^{0T}=1-z^{-1}$"></SPAN> which is basically a DC filter.

<P>

<H3><A ID="SECTION00078200000000000000">
Determining the data-flow diagram of an IIR filter</A>
</H3>

<DIV class="CENTER"><A ID="IIRfilter"></A><A ID="1729"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 21:</STRONG>
IIR filter</CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG STYLE=""
 SRC="img389.svg"
 ALT="\includegraphics[width=0.75\linewidth]{iir}">

</DIV></TD></TR>
</TABLE>
</DIV>
To get a practical implementation of Eq.&nbsp;<A HREF="#IIReq">157</A> we have
to see it with its input- and output-signals:
<BR>
<DIV ALIGN="CENTER"><A ID="Verg"></A>
<!-- MATH
 \begin{eqnarray}
Y(z)&=&X(z)H(z)\\
    &=&X(z) {1\over 1-e^{-bT} z^{-1}} \\
    &=&Y(z)z^{-1}e^{-bT}+X(z)
\end{eqnarray}
 -->
<TABLE CELLPADDING="0" ALIGN="CENTER" WIDTH="100%">
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img390.svg"
 ALT="$\displaystyle Y(z)$"></TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.00ex; vertical-align: -0.09ex; " SRC="img82.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img391.svg"
 ALT="$\displaystyle X(z)H(z)$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">161</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.00ex; vertical-align: -0.09ex; " SRC="img82.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 4.87ex; vertical-align: -1.82ex; " SRC="img392.svg"
 ALT="$\displaystyle X(z) {1\over 1-e^{-bT} z^{-1}}$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">162</SPAN>)</TD></TR>
<TR VALIGN="MIDDLE"><TD NOWRAP ALIGN="RIGHT">&nbsp;</TD>
<TD ALIGN="CENTER" NOWRAP><IMG STYLE="height: 1.00ex; vertical-align: -0.09ex; " SRC="img82.svg"
 ALT="$\textstyle =$"></TD>
<TD ALIGN="LEFT" NOWRAP><IMG STYLE="height: 2.71ex; vertical-align: -0.66ex; " SRC="img393.svg"
 ALT="$\displaystyle Y(z)z^{-1}e^{-bT}+X(z)$"></TD>
<TD CLASS="eqno" WIDTH=10 ALIGN="RIGHT">
(<SPAN CLASS="arabic">163</SPAN>)</TD></TR>
</TABLE></DIV>
<BR CLEAR="ALL"><P></P>
We have to recall that <SPAN CLASS="MATH"><IMG STYLE="height: 1.96ex; vertical-align: -0.09ex; " SRC="img394.svg"
 ALT="$z^{-1}$"></SPAN> is the delay by <SPAN CLASS="MATH"><IMG STYLE="height: 1.72ex; vertical-align: -0.09ex; " SRC="img30.svg"
 ALT="$T$"></SPAN>. With that
information we directly have a difference equation in the
temporal domain:

<DIV class="equation">

<!-- MATH
 \begin{equation}
y(nT)=y([n-1]T) e^{-bT} + x(nT)
\end{equation}
 -->
 &nbsp;  <A ID="IIRtime"></A><IMG STYLE="height: 2.71ex; vertical-align: -0.66ex; " SRC="img395.svg"
 ALT="$\displaystyle y(nT)=y([n-1]T) e^{-bT} + x(nT)
$"> 

(<SPAN CLASS="arabic">164</SPAN>)
</DIV>
This means that the output signal <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img396.svg"
 ALT="$y(nT)$"></SPAN> is calculated by
adding the weighted and delayed output signal <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img397.svg"
 ALT="$y([n-1]T)$"></SPAN> 
to the input signal <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img398.svg"
 ALT="$x(nT)$"></SPAN>.
How this actually works is shown in Fig.&nbsp;<A HREF="#IIRfilter">21</A>.
The attention is drawn to the <SPAN  CLASS="textsl">sign inversion</SPAN> of the weighting
factor <SPAN CLASS="MATH"><IMG STYLE="height: 2.04ex; vertical-align: -0.09ex; " SRC="img399.svg"
 ALT="$e^{-bT}$"></SPAN> in contrast to the transfer function 
Eq.&nbsp;<A HREF="#impInv">158</A> where it is <SPAN CLASS="MATH"><IMG STYLE="height: 2.23ex; vertical-align: -0.28ex; " SRC="img400.svg"
 ALT="$-e^{-bT}$"></SPAN>. In general the recursive
coefficients change sign when they are taken from the transfer
function.

<P>

<H3><A ID="SECTION00078300000000000000">
General form of IIR filters</A>
</H3>
A filter with forward and feedback components can be represented as:

<DIV class="equation">

<!-- MATH
 \begin{equation}
H(z) = \frac{\sum_{k = 0}^{r} B_{k} z^{-k}}{1 + \sum_{l = 1}^{m} A_{i} z^{-l}}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 5.65ex; vertical-align: -2.19ex; " SRC="img401.svg"
 ALT="$\displaystyle H(z) = \frac{\sum_{k = 0}^{r} B_{k} z^{-k}}{1 + \sum_{l = 1}^{m} A_{i} z^{-l}} $"> 

(<SPAN CLASS="arabic">165</SPAN>)
</DIV>
where <SPAN CLASS="MATH"><IMG STYLE="height: 2.06ex; vertical-align: -0.43ex; " SRC="img402.svg"
 ALT="$B_k$"></SPAN> are the FIR coefficients and <SPAN CLASS="MATH"><IMG STYLE="height: 2.06ex; vertical-align: -0.43ex; " SRC="img403.svg"
 ALT="$A_l$"></SPAN> the recursive coefficients.
Note the signs of the recursive coefficients are <SPAN  CLASS="textsl">inverted</SPAN> in the
actual implementation of the filter. This can be seen when the
function <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img268.svg"
 ALT="$H(z)$"></SPAN> is actually multiplied with an input signal to
obtain the output signal (see Eq.&nbsp;<A HREF="#IIRtime">164</A> and Fig.&nbsp;<A HREF="#IIRfilter">21</A>).
The &ldquo;1&rdquo; in the denominator represents actually the output of
the filter. If this factor is not one then the output will be scaled
by that factor. However, usually this is kept one.

<P>
In Python filtering is performed with the command:
<PRE>
import scipy.signal as signal
Y = signal.lfilter(B,A,X)
</PRE>
where B are the FIR coefficients, A the IIR coefficients and X is the input.
For a pure FIR filter we just have:
<PRE>
Y = signal.lfilter(B,1,X)
</PRE>
The &ldquo;1&rdquo; represents the output.

<P>

<H3><A ID="SECTION00078400000000000000">
IIR filter topologies</A>
</H3>

<DIV class="CENTER"><A ID="iir_types"></A><A ID="1734"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 22:</STRONG>
A) Direct Form I filter which one accumulator and
  B) Direct Form II filter with two accumlators.
</CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG STYLE=""
 SRC="img404.svg"
 ALT="\includegraphics[width=\textwidth]{iir_types}">

</DIV></TD></TR>
</TABLE>
</DIV>
In real applications one would create a <SPAN  CLASS="textsl">chain of 2nd order
IIR filters</SPAN>. This has numerous advantages:

<OL>
<LI>The optimisation can be done within these simple structures,
  for example omitting array operations completely and coding
  the 2nd order filters in assembly while keeping the higher
  level operations in C or C++.
</LI>
<LI>Control of stability issues: high order recursive
  systems might become unstable and it is very hard to predict
  when this might happen. On the other hand a chain of 2nd order
  filters can be made stable with ease. One can focus on
  stability in 2nd order systems which is well understood and
  manageable.
</LI>
<LI>Complex conjugate pole pairs are generated naturally
  in analogue filter design and directly translate to 2nd
  order IIR structures. Analogue design is usually described
  as 2nd order structures (=LCR) so that any transform from analogue
  to digital just needs to be of 2nd order!
</LI>
</OL>

<P>
Fig.&nbsp;<A HREF="#iir_types">22</A> shows the most popular filter topologies:
Direct Form I and II. Because of the linear operation of the filter
one is allowed to do the FIR and IIR operations in different orders.
In Direct From I we have one accumulator and two delay lines whereas
in the Direct Form II we have two accumulators and one delay line.
Only the Direct Form I is suitable for integer operations.

<P>
A Python class of a direct form II filter can be implemented
with a few lines:
<PRE>
class IIR_filter:
    def __init__(self,_num,_den):
        self.numerator = _num
        self.denominator = _den
        self.buffer1 = 0
        self.buffer2 = 0

    def filter(self,v):
        input=0.0
        output=0.0
        input=v
        output=(self.numerator[1]*self.buffer1)
        input=input-(self.denominator[1]*self.buffer1)
        output=output+(self.numerator[2]*self.buffer2)
        input=input-(self.denominator[2]*self.buffer2)
        output=output+input*self.numerator[0]
        self.buffer2=self.buffer1
        self.buffer1=input
        return output
</PRE>
Here, the two delay steps are represented by two variables
<SPAN  CLASS="texttt">buffer1</SPAN> and <SPAN  CLASS="texttt">buffer2</SPAN>.

<P>
In order to achive higher order filters one can then just
chain these 2nd order filters. In Python this can be achieved
by storing these in an array of instances of this class.

<P>

<H3><A ID="SECTION00078500000000000000">
Fixed point IIR filters</A>
</H3>

<DIV class="CENTER"><A ID="iir_fixed"></A><A ID="1736"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 23:</STRONG>
Direct Form I filter with fixed point arithmetic.
</CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG STYLE=""
 SRC="img405.svg"
 ALT="\includegraphics[width=0.5\textwidth]{iir_fixed}">

</DIV></TD></TR>
</TABLE>
</DIV>
Fig.&nbsp;<A HREF="#iir_fixed">23</A> shows the implementation of a fixed point IIR
filter. It's a Direct Form I filter with one accumulator so that
temporary overflows can be compensated. The original floating point
IIR coefficients are scaled up by factor <SPAN CLASS="MATH"><IMG STYLE="height: 1.64ex; vertical-align: -0.09ex; " SRC="img15.svg"
 ALT="$2^w$"></SPAN> so that they max out
the range of the integer coefficients. After the addition operation
they are shifted back by <SPAN CLASS="MATH"><IMG STYLE="height: 1.15ex; vertical-align: -0.09ex; " SRC="img14.svg"
 ALT="$w$"></SPAN>&nbsp;bits to their original values.

<P>
For example if the largest IIR coefficient is 1.9 and we use 16 bit
signed numbers (max number is 32767) then one could multiply all
coefficients with <SPAN CLASS="MATH"><IMG STYLE="height: 1.96ex; vertical-align: -0.09ex; " SRC="img406.svg"
 ALT="$2^{14}$"></SPAN>.

<P>
Then one needs to assess the maximum value in the accumulator which
is much more difficult than for FIR filters. For example,
resonators can generate high output values with even small input values
so that it's advisable to have a large overhead in the accumulator.
For example if the input signal is <SPAN CLASS="MATH"><IMG STYLE="height: 1.63ex; vertical-align: -0.09ex; " SRC="img291.svg"
 ALT="$16$"></SPAN>&nbsp;bit and the scaling factor is
<SPAN CLASS="MATH"><IMG STYLE="height: 1.63ex; vertical-align: -0.09ex; " SRC="img407.svg"
 ALT="$14$"></SPAN>&nbsp;bits then the signal will certainly occupy <SPAN CLASS="MATH"><IMG STYLE="height: 1.80ex; vertical-align: -0.27ex; " SRC="img408.svg"
 ALT="$16+14=30$"></SPAN>&nbsp;bits. With
an accumulator of 32 bits that gives only a headroom of 2&nbsp;bits so the
output can only be 4 times larger than the input. A 64 bit accumulator
is a safe bet.

<P>

<H3><A ID="SECTION00078600000000000000">
Filter design based on analogue filters</A>
</H3>

<DIV class="CENTER"><A ID="butterworth_poles"></A><A ID="1738"></A>
<TABLE>
<CAPTION class="BOTTOM"><STRONG>Figure 24:</STRONG>
Pole placements of the Butterworth filter. Its analogue
  cutoff frequency is <!-- MATH
 $\Omega = 2\pi F$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 1.72ex; vertical-align: -0.09ex; " SRC="img22.svg"
 ALT="$\Omega = 2\pi F$"></SPAN> where <SPAN CLASS="MATH"><IMG STYLE="height: 1.72ex; vertical-align: -0.09ex; " SRC="img3.svg"
 ALT="$F$"></SPAN> is the
  analogue cutoff frequency in Hertz. This filter can be implemented
  as a chain of 2nd order IIR filters (biquads) by using the
  complex conjugate pairs for the different 2nd order IIR filters.
</CAPTION>
<TR><TD>
<DIV class="CENTER">
<IMG STYLE=""
 SRC="img409.svg"
 ALT="\includegraphics[width=0.5\textwidth]{butterworth_poles}">

</DIV></TD></TR>
</TABLE>
</DIV>
Most IIR filters are designed from analogue filters by transforming
from the continuous domain (<SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img410.svg"
 ALT="$h(t),H(s)$"></SPAN>) to the sampled domain
(<SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img411.svg"
 ALT="$h(n),H(z)$"></SPAN>).

<P>

<H4><A ID="SECTION00078610000000000000">
A list of popular analogue transfer functions being
used for IIR filter design:</A>
</H4>

<P>

<UL>
<LI><B>Butterworth:</B> All poles lie on the left half plane
  equally distributed on a half circle with radius <!-- MATH
 $\Omega = 2\pi F$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 1.72ex; vertical-align: -0.09ex; " SRC="img22.svg"
 ALT="$\Omega = 2\pi F$"></SPAN> which
  is shown in Fig.&nbsp;<A HREF="#butterworth_poles">24</A>. The Butterworth filter
  is by far the most popular filter. Here are its properties:

<UL>
<LI>monotonic frequency response
</LI>
<LI>only poles, no zeros
</LI>
<LI>the Poles have analytical solution and very easy to calculate
</LI>
<LI>no constant group delay but usually acceptable deviation from
  a strict constant group delay for many applications.
</LI>
</UL>

<P>
</LI>
<LI><B>Chebyshev Filters:</B>

<DIV class="equation">

<!-- MATH
 \begin{equation}
|H(\Omega)|^{2} = \frac{1}{1 - \varepsilon^{2} T_{N} (\Omega/\Omega_{p})}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 5.31ex; vertical-align: -2.27ex; " SRC="img412.svg"
 ALT="$\displaystyle \vert H(\Omega)\vert^{2} = \frac{1}{1 - \varepsilon^{2} T_{N} (\Omega/\Omega_{p})}
$"> 

(<SPAN CLASS="arabic">166</SPAN>)
</DIV>
where T = Chebyslev polynomials. These filters have either ripples
in the stop or passband depending on the choice of polynomials.
As with Butterworth the polynomials have analytical solutions for
the poles and zeros of the filter so that their design again is
straightforward.

<P>
</LI>
<LI><B>Bessel Filter: </B>

<UL>
<LI>Constant Group Delay
</LI>
<LI>Shallow transition from stop- to passband
</LI>
<LI>No analytical solution for the poles/zeros.
</LI>
</UL>
</LI>
</UL>

<P>

<H4><A ID="SECTION00078620000000000000">
How to transform the analogue lowpass filters into
  highpass, bandstop or bandpass filters?</A>
</H4>
All the analogue transfer functions above are lowpass
filters. However this is not a limitation because there are handy transforms
which take an analogue lowpass transfer function or poles/zeros
and then transforms them into highpass, bandpass and stopband
filters. These rules can be found in any good analogue filter
design book and industry handouts, for example from Analog Devices.

<P>

<H4><A ID="SECTION00078630000000000000">
Bilinear Transform: transforming the analoge transfer function into a digital one:</A>
</H4>
As a next step these analogue transfer functions <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img251.svg"
 ALT="$H(s)$"></SPAN> need to be
transformed to digital transfer functions <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img268.svg"
 ALT="$H(z)$"></SPAN>. This could be done
by the matched z-transform
(Eq.&nbsp;<A HREF="#matchedz">160</A>). However, the problem with these methods is that
they map frequencies 1:1 between the digital and analogue
domain. Remember: in the sampled domain there is no infinite frequency
but <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img134.svg"
 ALT="$F_s/2$"></SPAN> which is the Nyquist frequency.  This means that we never
get more damping than at Nyquist <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img134.svg"
 ALT="$F_s/2$"></SPAN>.  This is especially a
problem for lowpass filters where damping increases the higher the
frequency.

<P>
The solution is to map <B>all</B> analogue frequencies from <!-- MATH
 $0 \ldots \infty$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 1.63ex; vertical-align: -0.09ex; " SRC="img413.svg"
 ALT="$0 \ldots \infty$"></SPAN>
to the sampled frequencies <SPAN CLASS="MATH"><IMG STYLE="height: 1.63ex; vertical-align: -0.09ex; " SRC="img41.svg"
 ALT="$0\ldots 0.5$"></SPAN> in a non-linear way:

<DIV class="equation">

<!-- MATH
 \begin{equation}
- \infty < \Omega < \infty \Rightarrow -\pi \leq \omega \leq \pi
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 2.02ex; vertical-align: -0.40ex; " SRC="img414.svg"
 ALT="$\displaystyle - \infty &lt; \Omega &lt; \infty \Rightarrow -\pi \leq \omega \leq \pi
$"> 

(<SPAN CLASS="arabic">167</SPAN>)
</DIV>
This is called <SPAN  CLASS="textsl">Bilinear Transformation</SPAN>:

<DIV class="equation">

<!-- MATH
 \begin{equation}
s = \frac{2}{T} \quad \frac{z - 1}{z + 1}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 4.86ex; vertical-align: -1.81ex; " SRC="img415.svg"
 ALT="$\displaystyle s = \frac{2}{T} \quad \frac{z - 1}{z + 1}
$"> 

(<SPAN CLASS="arabic">168</SPAN>)
</DIV>
This rule replaces all <SPAN CLASS="MATH"><IMG STYLE="height: 1.15ex; vertical-align: -0.09ex; " SRC="img253.svg"
 ALT="$s$"></SPAN> with <SPAN CLASS="MATH"><IMG STYLE="height: 1.15ex; vertical-align: -0.09ex; " SRC="img254.svg"
 ALT="$z$"></SPAN> in our analogue transfer
function so that it's now digital. However, the cutoff frequency <SPAN CLASS="MATH"><IMG STYLE="height: 2.06ex; vertical-align: -0.43ex; " SRC="img416.svg"
 ALT="$\Omega_c$"></SPAN>
is still an analogue one but if we want to design a digital filter
we want to specify a digital cutoff frequency. Plus remember that
the frequency mapping is non-linear so that there is non-linear
mapping also of the cutoff. 

<P>
In the analogue domain the
frequency is given as <SPAN CLASS="MATH"><IMG STYLE="height: 2.16ex; vertical-align: -0.53ex; " SRC="img417.svg"
 ALT="$s = j\Omega$"></SPAN> and in the sampled domain as
<!-- MATH
 $z = e^{j \omega}$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 1.99ex; vertical-align: -0.09ex; " SRC="img257.svg"
 ALT="$z = e^{j \omega}$"></SPAN>. With the definition of the bilinear transform
we can establish how to map from our desired digital cutoff to
the analogue one:

<DIV class="equation">

<!-- MATH
 \begin{equation}
j \Omega = \frac{2}{T} \left[\frac{e^{j \omega} - 1}{e^{j \omega} +1}\right] = \frac{2}{T} j \tan \frac{\omega}{2}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 5.79ex; vertical-align: -2.34ex; " SRC="img418.svg"
 ALT="$\displaystyle j \Omega = \frac{2}{T} \left[\frac{e^{j \omega} - 1}{e^{j \omega} +1}\right] = \frac{2}{T} j \tan \frac{\omega}{2}
$"> 

(<SPAN CLASS="arabic">169</SPAN>)
</DIV>
This derivation is useful for two purposes. It shows the non-linear
mapping between the digital and analogue world and it provides
a recipe how to calculate our analogue cutoff frequency.

<P>
That the bilinear transform is a 
<B>non</B>linear mapping between the analogue world and the digital
world can be directly seen by just omitting the <SPAN CLASS="MATH"><IMG STYLE="height: 2.09ex; vertical-align: -0.53ex; " SRC="img419.svg"
 ALT="$j$"></SPAN>:

<DIV class="equation">

<!-- MATH
 \begin{equation}
\Omega = \frac{2}{T} tan \frac{\omega}{2}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 4.69ex; vertical-align: -1.64ex; " SRC="img420.svg"
 ALT="$\displaystyle \Omega = \frac{2}{T} tan \frac{\omega}{2}
$"> 

(<SPAN CLASS="arabic">170</SPAN>)
</DIV>

<P>
This also means that the cut-off frequency of our analogue filter is changed
by the bilinear transformation. Consequently, we need to apply the same
transformation to the cutoff frequency itself:

<DIV class="equation">

<!-- MATH
 \begin{equation}
\Omega_{c} = \frac{2}{T} tan \frac {\omega_{c}}{2}
\end{equation}
 -->
 &nbsp;  <A ID="prewarp"></A><IMG STYLE="height: 4.69ex; vertical-align: -1.64ex; " SRC="img421.svg"
 ALT="$\displaystyle \Omega_{c} = \frac{2}{T} tan \frac {\omega_{c}}{2}
$"> 

(<SPAN CLASS="arabic">171</SPAN>)
</DIV>
where <SPAN CLASS="MATH"><IMG STYLE="height: 1.72ex; vertical-align: -0.09ex; " SRC="img30.svg"
 ALT="$T$"></SPAN> is the sampling interval. This is often called &ldquo;pre-warp&rdquo;
but is simply the application of the same rule to the cut-off
frequency as what the bilinear transform does to the transfer function
<SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img251.svg"
 ALT="$H(s)$"></SPAN>. It has also another important result: we can now finally
specify our cut-off in the sampled domain in normalised frequencies
<!-- MATH
 $\omega_{c} = 2\pi f_{c}$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.18ex; vertical-align: -0.53ex; " SRC="img422.svg"
 ALT="$\omega_{c} = 2\pi f_{c}$"></SPAN> by using Eq.&nbsp;<A HREF="#prewarp">171</A>. After all we
just use the analogue filter as a vehicle to design a digital filter.

<P>
We can now list our design steps.

<P>

<H4><A ID="SECTION00078640000000000000">
IIR filter design steps:</A>
</H4>

<OL>
<LI>Choose the cut-off frequency of your digital filter <SPAN CLASS="MATH"><IMG STYLE="height: 1.49ex; vertical-align: -0.43ex; " SRC="img423.svg"
 ALT="$\omega_{c}$"></SPAN>.
</LI>
<LI>Calculate the analogue cutoff frequency <!-- MATH
 $\omega_{c} \rightarrow
  \Omega_{c}$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.06ex; vertical-align: -0.43ex; " SRC="img424.svg"
 ALT="$\omega_{c} \rightarrow
\Omega_{c}$"></SPAN> with Eq.&nbsp;<A HREF="#prewarp">171</A>
</LI>
<LI>Choose your favourite analogue lowpass filter <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img251.svg"
 ALT="$H(s)$"></SPAN>,
for example Butterworth.
</LI>
<LI>Replace all <SPAN CLASS="MATH"><IMG STYLE="height: 1.15ex; vertical-align: -0.09ex; " SRC="img253.svg"
 ALT="$s$"></SPAN> in the analogue transfer function
<SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img251.svg"
 ALT="$H(s)$"></SPAN> by <!-- MATH
 $s = \frac{2}{T} \frac{z - 1}{z + 1}$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.96ex; vertical-align: -1.03ex; " SRC="img425.svg"
 ALT="$s = \frac{2}{T} \frac{z - 1}{z + 1}$"></SPAN> 
to obtain the digital filter <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img268.svg"
 ALT="$H(z)$"></SPAN>
</LI>
<LI>Change the transfer function <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img268.svg"
 ALT="$H(z)$"></SPAN> so that it only contains
negative powers of <SPAN CLASS="MATH"><IMG STYLE="height: 1.15ex; vertical-align: -0.09ex; " SRC="img254.svg"
 ALT="$z$"></SPAN> (<!-- MATH
 $z^{-1}, z^{-2}, \ldots$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.40ex; vertical-align: -0.53ex; " SRC="img426.svg"
 ALT="$z^{-1}, z^{-2}, \ldots$"></SPAN>) which can be
interpreted as delay lines.
</LI>
<LI>Build your IIR filter!
</LI>
</OL>

<P>
For filter-orders higher than two one needs to develop a different
strategy because the bilinear transform is a real <SPAN  CLASS="textsl">pain</SPAN> to
calculate for anything above the order of two. Nobody wants to
transform high order analogue transfer functions <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img251.svg"
 ALT="$H(s)$"></SPAN> to the <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img268.svg"
 ALT="$H(z)$"></SPAN>
domain. However, there is an important property of all analogue
transfer functions: they generate complex conjugate pole pairs (plus
one real pole if of of odd order) which suggest a chain of 2nd order IIR
filters straight away (see Fig.&nbsp;<A HREF="#butterworth_poles">24</A>). Remember
that a complex conjugate pole pair creates a 2nd order IIR filter with
with two delay steps. A real pole is a 1st order IIR filter with one
delay but is often also implemented as a 2nd order filter where the
coefficients of the 2nd delay are kept zero.

<P>
The design strategy is thus to split up the analogue transfer function
<SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img251.svg"
 ALT="$H(s)$"></SPAN> in a chain of 2nd order filters <!-- MATH
 $H(s) = H_1(s) H_2(s) H_3(s)
\ldots$
 -->
<SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img427.svg"
 ALT="$H(s) = H_1(s) H_2(s) H_3(s)
\ldots$"></SPAN> and then to apply the bilinear transform on every 2nd order
term separately. Using this strategy you only need to calculate the bilinear
transform once for a 2nd order system (or if the order is odd then
also for a 1st order one) but then there is no need to do any more
painful bilinear transforms. This is standard practise in IIR filter
design.

<P>

<H4><A ID="SECTION00078650000000000000">
Time or frequency domain?</A>
</H4>
The transforms from analogue to digital alter both the temporal
response and the frequency response. However the different transforms
have different impact. The bilinear transform guarantees that the
digital filter uses the whole frequency range of the analogue filter
from zero to infinity which is the best solution for frequency domain
problems. However, if one needs to reproduce the temporal response an
analogue filter as faithfully as possible then the matched z transform
is best because it's based (as the name suggests) on the impulse
invariance method which aims to preserve the temporal behaviour of the
filter (exact for pole-only transfer functions).

<P>
<DIV class="CENTER">
<TABLE class="PAD " style="">
<TR><TD CLASS="LEFT">Identical frequency response required:</TD>
<TD CLASS="LEFT">Bilinear transform</TD>
</TR>
<TR><TD CLASS="LEFT">Identical temporal behaviour required:</TD>
<TD CLASS="LEFT">Matched z-transform</TD>
</TR>
</TABLE>
</DIV>

<P>
Of course a 100% match won't be achieved but in practise this
can be assumed. In most cases the bilinear transform is the
transform of choice. The matched z transform can be very useful,
for example in robotics where timing is important.

<P>

<H3><A ID="SECTION00078700000000000000">
Adaptive IIR filter: The Kalman filter</A>
</H3>
Often signals are contaminated by high frequency noise where the
spectrum of the noise is changing or not known. The cutoff of a fixed low
pass filter is not known or might be changing so that we need to adapt the cut-off continuously.
One example is a Kalman filter which maximises the
<SPAN  CLASS="textsl">predictability</SPAN> of the filtered signal. It's an adaptive lowpass filter
which increases the predictability of a signal because it smoothes it.

<DIV class="equation">

<!-- MATH
 \begin{equation}
H(z) = \frac{b}{1 - a z^{-1}}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 4.99ex; vertical-align: -1.82ex; " SRC="img428.svg"
 ALT="$\displaystyle H(z) = \frac{b}{1 - a z^{-1}}
$"> 

(<SPAN CLASS="arabic">172</SPAN>)
</DIV>
The parameter <SPAN CLASS="MATH"><IMG STYLE="height: 1.15ex; vertical-align: -0.09ex; " SRC="img429.svg"
 ALT="$a$"></SPAN> determines the cutoff frequency.
Frequency Response :

<DIV class="equation">

<!-- MATH
 \begin{equation}
|H(e^{j \omega}) | = |\frac{b}{1 - a e^{-j \omega}}|
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 4.99ex; vertical-align: -1.82ex; " SRC="img430.svg"
 ALT="$\displaystyle \vert H(e^{j \omega}) \vert = \vert\frac{b}{1 - a e^{-j \omega}}\vert
$"> 

(<SPAN CLASS="arabic">173</SPAN>)
</DIV>
Let's re-interpret our low-pass filter in the time domain:

<DIV class="equation">

<!-- MATH
 \begin{equation}
\underbrace{y(n)}_{\mbox {\footnotesize actual estimate}} = a(n) \underbrace{y(n - 1)}_{\mbox{\footnotesize previous estimate}} + b(n)\underbrace{x(n)}_{\mbox{\footnotesize current data sample}}
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 5.93ex; vertical-align: -4.17ex; " SRC="img431.svg"
 ALT="$\displaystyle \underbrace{y(n)}_{\mbox {\footnotesize actual estimate}} = a(n) ...
...estimate}} + b(n)\underbrace{x(n)}_{\mbox{\footnotesize current data sample}}
$"> 

(<SPAN CLASS="arabic">174</SPAN>)
</DIV>
We would like to have the best estimate for <SPAN CLASS="MATH"><IMG STYLE="height: 2.43ex; vertical-align: -0.66ex; " SRC="img18.svg"
 ALT="$y(n)$"></SPAN>

<DIV class="equation">

<!-- MATH
 \begin{equation}
p(n) = E[ \left( y (k) - y_{real} (k)\right)^{2}]
\end{equation}
 -->
 &nbsp;  <IMG STYLE="height: 2.80ex; vertical-align: -0.66ex; " SRC="img432.svg"
 ALT="$\displaystyle p(n) = E[ \left( y (k) - y_{real} (k)\right)^{2}]
$"> 

(<SPAN CLASS="arabic">175</SPAN>)
</DIV>
We need to minimise <SPAN CLASS="MATH"><IMG STYLE="height: 1.59ex; vertical-align: -0.53ex; " SRC="img433.svg"
 ALT="$p$"></SPAN> which gives us equations for a and b which
implements a Kalman filter.

<P>

<DIV CLASS="navigation"><HR></DIV>
<!--End of Navigation Panel-->
<p><a href="https://github.com/berndporr/digital_signal_processing">github / contact</a></p><P><A REL="license" HREF="http://creativecommons.org/licenses/by-sa/4.0/"><IMG ALT="Creative Commons License" SRC="https://i.creativecommons.org/l/by-sa/4.0/80x15.png" /></A></P>
</BODY>
</HTML>
